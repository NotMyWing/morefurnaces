import java.util.regex.Pattern
import groovy.json.JsonSlurper

import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.StringBody;
import groovyx.net.http.ContentType
import groovyx.net.http.HTTPBuilder
import groovyx.net.http.Method

buildscript {
    repositories {
        jcenter()
        maven { url = "http://files.minecraftforge.net/maven" }
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.3-SNAPSHOT'
        classpath "org.codehaus.groovy.modules.http-builder:http-builder:0.7"
        classpath "org.apache.httpcomponents:httpmime:4.5.1"
    }
}
apply plugin: 'net.minecraftforge.gradle.forge'

//Only edit below this line, the above code adds and enables the nessasary things for Forge to be setup.

version = "1.12.2-1.10.7"
group = "omnifactorydevs.morefurnaces" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "MoreFurnaces Omnifactory Edition"

sourceCompatibility = 1.8
targetCompatibility = 1.8

minecraft {
    version = "1.12.2-14.23.5.2847"
    runDir = "run"
    mappings = "snapshot_20171003"
    makeObfSourceJar = false

    replace "GRADLE:VERSION", project.version
}

repositories {

    maven {
       url = "https://minecraft.curseforge.com/api/maven"
    }

    maven {
        url = "https://dvs1.progwml6.com/files/maven/"
    }

}

dependencies {
    testCompile 'junit:junit:4.5'

    implementation 'cxlibrary:cxlibrary:1.12.1:1.6.1'
    runtime 'cxlibrary:cxlibrary:1.12.1:1.6.1'

    runtime "mezz.jei:jei_1.12.2:4.15.0.293"

}

processResources
{
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }

    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

def run = { command ->
    def process = command.execute()
    process.waitFor()
    return process.text.trim()
}

task ciRewriteVersion {
	onlyIf {
        System.env['TRAVIS']
    }

    doLast {
        if (System.env['TRAVIS_TAG']) {
            if (System.env['TRAVIS_TAG'] != project.version) {
                throw new GradleException("Invalid git tag. Expected "
                    + "${project.version}, got ${System.env["TRAVIS_TAG"]}"
                )
            }
        } else {
            def lastTag = run "git describe --abbrev=0 --tags"
            def commitNo = run "git rev-list ${lastTag}..HEAD --count"

            project.version += "." + commitNo
        }
    }
}

jar.dependsOn ciRewriteVersion

task deployCurseForge {
    dependsOn ciRewriteVersion

    doLast {
        def final CURSEFORGE_ENDPOINT = "https://minecraft.curseforge.com/"

        /*
            Helper function for checking environmental variables.
         */
        def final checkVariables = { variables -> 
            for (vari in variables) {
                if (!System.env[vari]) {
                    throw new GradleException("Environmental variable ${vari} is unset")
                }
            }
        }

        checkVariables([
            'CURSEFORGE_API_TOKEN', 'CURSEFORGE_PROJECT_ID'
        ])

        /*
            Helper function for fetching JSON data.
         */
        def final fetch = { url, headers = null -> 
            def connection = new URL(url).openConnection();
            connection.setRequestProperty("X-Api-Token", System.env["CURSEFORGE_API_TOKEN"])
            if (headers != null) {
                for (header in headers) {
                    connection.setRequestProperty(headers[1], headers[2])
                }
            }

            def code = connection.getResponseCode()
            if (code == 200) {
                return new JsonSlurper().parseText(connection.getInputStream().getText())
            } else {
                throw new GradleException("Fetch failed with code ${code} (${url})")
            }
        }

        /*
            Parse the version slug.
         */
        def parsedSlug = (project.version =~ /^(.+)-(.+)$/).with {
            if (size() == 0) {
                throw new GradleException("Couldn't parse the version slug: ${project.version}")
            }

            return it.findAll()[0]
        }
 
        /*
            Fetch the list of Minecraft versions from CurseForge.
         */
        def version = fetch(CURSEFORGE_ENDPOINT + "api/game/versions").with {
            def v = it.find { it.name == parsedSlug[1] }

            if (!v) {
                throw new GradleException("Version ${parsedSlug[1]} not found on CurseForge.")
            }

            return v
        }

        /*
            Create a comprehensive changelog.
         */
        def final createChangeLog = {
            def lastTag = System.env['TRAVIS_TAG'] ?
                run("git describe --abbrev=0 --tags `git rev-list --tags --skip=1 --max-count=1`")
                : run("git describe --abbrev=0 --tags")
            
            def log = "Changes since ${lastTag}:"
            log += "\n"
            log += ("\n" + run("git log --date=format:\"%d %b %Y\" --pretty=\"%s - **%an** (%ad)\" ${lastTag}..HEAD"))
                .replaceAll("\n", "\r\nâ€¢ ")

            return log
        }

        /*
            Fill the papers for CurseForge.
         */
        def metadata = new groovy.json.JsonBuilder().with {
            def versions = [ version.id ]
            def root = it {
                changelog createChangeLog()
                changelogType "markdown"

                releaseType System.env['TRAVIS_TAG'] ? "release" : "beta"
                gameVersions versions

                // Defined in gradle.properties
                displayName "${curseforge_fancyArtifactName} ${parsedSlug[2]} for ${parsedSlug[1]}"
            }

            return it.toString()
        }

        /*
            Upload the artifact to CurseForge.
         */

        new HTTPBuilder(CURSEFORGE_ENDPOINT).request(Method.POST) { req ->
            requestContentType = "multipart/form-data"
            headers["X-Api-Token"] = System.env["CURSEFORGE_API_TOKEN"]
            uri.path = "api/projects/${System.env["CURSEFORGE_PROJECT_ID"]}/upload-file"

            req.entity = new MultipartEntityBuilder().with {
                addPart("file", new FileBody(
                    new File("${project.jar.destinationDir}\\${project.jar.archiveName}")
                ))
                addPart("metadata", new StringBody(metadata))

                return it.build()
            }
        }
    }
}
